![BrightCoders Logo](img/logo.png)

- [Cifrado de Vigenere](#cifrado-de-vigenere)
- [Objetivo](#objetivo)
- [Instrucciones](#instrucciones)
- [Entregables](#entregables)
- [Indicadores de cumplimiento](#indicadores-de-cumplimiento)
- [Flujo de trabajo](#flujo-de-trabajo)
  - [D√≠a 1](#d√≠a-1)
  - [D√≠a 2](#d√≠a-2)
  - [D√≠a 3](#d√≠a-3)
  - [D√≠a 4 - 5](#d√≠a-4---5)
- [Tecnolog√≠as](#tecnolog√≠as)
- [Requerimientos funcionales](#requerimientos-funcionales)
- [Requerimientos no funcionales](#requerimientos-no-funcionales)
- [Recursos](#recursos)

# üöÄ Cifrado de Vigenere

- **Organizaci√≥n.**  [Individual](https://github.com/BrightCoders-Institute/handbook/wiki/Actividades#actividades-individuales-as%C3%ADncronas)
- **Modo.** [S√≠ncrono](https://github.com/BrightCoders-Institute/handbook/wiki/Actividades#actividades-individuales-as%C3%ADncronas)
- **Estrategia.** Programaci√≥n individual
- **Duraci√≥n.** 5 d√≠as
- **Dedicaci√≥n.** 1.5 horas diarias (7.5 horas total)

# üéØ Objetivo

Esta actividad tiene como objetivos:

- **Practicar la sem√°ntica y sintaxis de Ruby:** Desarrollar habilidades s√≥lidas en el uso correcto de la sintaxis y las convenciones de nomenclatura de Ruby, as√≠ como comprender y aplicar adecuadamente los conceptos sem√°nticos del lenguaje.
- **Utilizar RuboCop para mejorar la calidad del c√≥digo Ruby:** Familiarizarse con la herramienta RuboCop y utilizarla como gu√≠a para garantizar la consistencia y legibilidad del c√≥digo, siguiendo las mejores pr√°cticas y convenciones de estilo de Ruby.
- **Aplicar principios de programaci√≥n orientada a objetos en Ruby:** Comprender y aplicar los conceptos fundamentales de la programaci√≥n orientada a objetos (POO) en Ruby, como encapsulaci√≥n, herencia, polimorfismo y abstracci√≥n, para crear c√≥digo modular, reutilizable y f√°cil de mantener.
- **Emplear el polimorfismo como una soluci√≥n mejor a las banderas booleanas:** Practicar el uso del polimorfismo en situaciones donde se utilizan banderas booleanas, aprovechando la capacidad de los objetos de comportarse de diferentes formas seg√∫n su tipo, lo que promueve un dise√±o m√°s limpio, extensible y f√°cil de entender.
- **Practicar el desarrollo basado en pruebas con Ruby, RSpec y/o MiniTest:** Adquirir experiencia en el desarrollo de pruebas unitarias y funcionales utilizando frameworks populares como RSpec y/o MiniTest, para garantizar la calidad y robustez del c√≥digo, as√≠ como facilitar la detecci√≥n temprana de errores y el mantenimiento a largo plazo.
- **Introducir los principios SOLID:** Familiarizarse con los principios SOLID (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) y aplicarlos en el dise√±o y desarrollo de software, buscando lograr un c√≥digo m√°s modular, flexible y f√°cil de mantener.

# üìã Instrucciones

- Utilizando Ruby, se desarrollar√° una soluci√≥n completa para el algoritmo que se explica en la secci√≥n de __requerimientos funcionales__.
- Se utilizar√° RuboCop para garantizar la consistencia y legibilidad del c√≥digo, siguiendo las mejores pr√°cticas y convenciones de estilo de Ruby.
- La soluci√≥n deber√° seguir el enfoque orientado a objetos.
- Se pondr√° en pr√°ctica el concepto de desarrollo basado en pruebas utilizando RSpec o MiniTest.
- Se aplicar√° el concepto de commits significativos.

# üì• Entregables

- C√≥digo Ruby funcional y completo en la rama principal de este repositorio.
- Implementaci√≥n orientada a objetos que refleje los principios de la programaci√≥n orientada a objetos en Ruby.
- Reemplazo de banderas booleanas por polimorfismo en situaciones pertinentes, mejorando el dise√±o del c√≥digo.
- Archivo de configuraci√≥n de RuboCop aplicado al proyecto para garantizar la calidad del c√≥digo.
- Conjunto completo de pruebas unitarias y funcionales desarrolladas con RSpec y/o MiniTest para verificar el correcto funcionamiento del c√≥digo.
- Archivo README.md actualizado con las instrucciones de ejecuci√≥n y cualquier otra informaci√≥n relevante.

# ‚úÖ Indicadores de cumplimiento

1. Sintaxis y sem√°ntica de Ruby:
   - El c√≥digo debe estar escrito utilizando la sintaxis correcta de Ruby.
   - Se deben utilizar las convenciones de nomenclatura adecuadas de Ruby.

2. Uso de RuboCop:
   - Se debe utilizar RuboCop como herramienta de an√°lisis est√°tico para mejorar la calidad del c√≥digo Ruby.

3. Programaci√≥n orientada a objetos:
   - Deben aplicarse los conceptos fundamentales de la programaci√≥n orientada a objetos, como encapsulaci√≥n, herencia, polimorfismo y abstracci√≥n.
   - El c√≥digo debe ser modular, reutilizable y f√°cil de mantener.

4. Uso de polimorfismo en lugar de banderas booleanas:
   - Deben identificarse situaciones en las que se utilizan banderas booleanas y reemplazarlas por polimorfismo.

5. Desarrollo basado en pruebas:
   - Se deben desarrollar pruebas unitarias y funcionales utilizando RSpec y/o MiniTest.
   - Las pruebas deben garantizar la calidad y robustez del c√≥digo.

6. Aplicaci√≥n de los principios SOLID:
   - Deben aplicarse los principios SOLID (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) en el dise√±o y desarrollo del software.
   - El c√≥digo debe ser modular, flexible y f√°cil de mantener.

# üí° Flujo de trabajo

A continuaci√≥n se presenta un flujo de trabajo sugerido para el desarrollo del algoritmo. Si se decide seguir otro enfoque, es v√°lido siempre y cuando se logre el mismo resultado:

## D√≠a 1

- Comienza a codificar la soluci√≥n del algoritmo centr√°ndote en establecer una base s√≥lida. Utiliza el enfoque orientado a objetos y recuerda que este ejercicio es principalmente para aprender y familiarizarte con Ruby.

## D√≠a 2

- Contin√∫a desarrollando la soluci√≥n, esta vez reemplazando las banderas booleanas por polimorfismo en situaciones relevantes. Esto mejorar√° el dise√±o del c√≥digo y te permitir√° explorar las capacidades flexibles de Ruby.

## D√≠a 3

- Sigue avanzando en el desarrollo de la soluci√≥n y aseg√∫rate de incorporar el uso de RuboCop. Utiliza esta herramienta para mantener la consistencia y la legibilidad del c√≥digo, siguiendo las mejores pr√°cticas y convenciones de estilo de Ruby.
- Contin√∫a aprendiendo y experimentando con Ruby. Recuerda que no es necesario completar la soluci√≥n en este momento, ya que el objetivo principal es el aprendizaje.

## D√≠a 4 - 5

- Lleg√≥ el momento de finalizar la soluci√≥n. Aseg√∫rate de incorporar pruebas unitarias y funcionales utilizando frameworks populares como RSpec y/o MiniTest. Estas pruebas garantizar√°n la calidad y robustez del c√≥digo, permitiendo la detecci√≥n temprana de errores y facilitando el mantenimiento a largo plazo.
- Enf√≥cate en escribir m√©todos peque√±os y con un solo prop√≥sito. Esto mejorar√° la legibilidad y el mantenimiento del c√≥digo.
- Adem√°s, aprovecha este tiempo para estudiar y aplicar los principios SOLID en tu c√≥digo, buscando lograr un dise√±o modular y flexible.

Recuerda que el objetivo principal de este flujo de trabajo es aprender y mejorar tus habilidades en Ruby. Lo importante es el proceso de aprendizaje y la adquisici√≥n de nuevos conocimientos.

# üõ† Tecnolog√≠as

- Ruby
- Rubocop
- [RSpec](https://rspec.info/)
- [Minitest](https://github.com/minitest/minitest)

# üßëüèª‚Äçüíª Requerimientos funcionales

El cifrado de Vigen√®re es un tipo de cifrado polialfab√©tico, lo que significa que utiliza diferentes alfabetos para cifrar un mensaje. El algoritmo se basa en una tabla conocida como la tabla de Vigen√®re o tabla de coincidencias, que es esencial para su implementaci√≥n.

A continuaci√≥n tienes la explicaci√≥n paso a paso del cifrado de Vigen√®re con dos palabras diferentes como ejemplos:

## Cifrado de Vigen√®re: Explicaci√≥n Paso a Paso

1. **Definir el mensaje original y la clave de cifrado:**
   - El mensaje original es el texto que se desea cifrar.
   - La clave de cifrado es una palabra o frase que se utilizar√° para cifrar el mensaje.

   **Ejemplo 1:**
   - Mensaje original: ‚ÄúHOLA‚Äù
   - Clave de cifrado: ‚ÄúSECRETO‚Äù

   **Ejemplo 2:**
   - Mensaje original: ‚ÄúRUBY‚Äù
   - Clave de cifrado: ‚ÄúCOD‚Äù

2. **Convertir el mensaje original y la clave a valores num√©ricos:**
   - Asignar un n√∫mero a cada letra del mensaje original y la clave seg√∫n su posici√≥n en el alfabeto. Por ejemplo, A=0, B=1, C=2, etc.

   **Ejemplo 1:**
   - Mensaje original: H=7, O=15, L=11, A=0
   - Clave de cifrado: S=19, E=4, C=2, R=18, E=4, T=20, O=15

   **Ejemplo 2:**
   - Mensaje original: R=18, U=21, B=1, Y=25
   - Clave de cifrado: C=2, O=15, D=3

3. **Repetir la clave para que tenga la misma longitud que el mensaje original:**
   - Repetir la clave hasta alcanzar o superar la longitud del mensaje original. Esto se hace para asegurar que haya suficientes caracteres de la clave para cifrar cada letra del mensaje original.

   **Ejemplo 1:**
   - Mensaje original: HOLA
   - Clave repetida: SECRETO
  
   - En este primer ejemplo no se ocupa repetir la clave pues la longitud de la clave es mayor la del mensaje original

   **Ejemplo 2:**
   - Mensaje original: RUBY
   - Clave repetida: CODC
  
   - En este ejemplo, si es necesario repetir la clave, por que las longitudes son iguales, por esto se agrega la letra C al final

4. **Cifrar el mensaje original:**
   - Para cada letra del mensaje original, realizar los siguientes pasos:
     - Obtener el valor num√©rico de la letra del mensaje original.
     - Obtener el valor num√©rico correspondiente de la letra de la clave repetida.
     - Sumar los valores num√©ricos utilizando aritm√©tica modular para obtener el valor num√©rico cifrado.
     - Convertir el valor num√©rico cifrado en una letra utilizando el alfabeto.

   **Ejemplo 1:**
   - Letra 1: H (valor num√©rico: 7) + S (valor num√©rico: 19) = Z (valor num√©rico cifrado: 26) -> Letra cifrada: Z
   - Letra 2: O (valor num√©rico: 15) + E (valor num√©rico: 4) = S (valor num√©rico cifrado: 19) -> Letra cifrada: S
   - Letra 3: L (valor num√©rico: 11) + C (valor num√©rico: 2) = N (valor num√©rico cifrado: 13) -> Letra cifrada: N
   - Letra 4: A (valor num√©rico: 0) + R (valor num√©rico: 18) = R (valor num√©rico cifrado: 18) -> Letra cifrada: R

   **Ejemplo 2:**
   - Letra 1: R (valor num√©rico: 18) + C (valor num√©rico: 2) = T (valor num√©rico cifrado: 20) -> Letra cifrada: T
   - Letra 2: U (valor num√©rico: 21) + O (valor num√©rico: 15) = J (valor num√©rico cifrado: 36-26) -> Letra cifrada: J
   - Letra 3: B (valor num√©rico: 1) + D (valor num√©rico: 3) = E (valor num√©rico cifrado: 4) -> Letra cifrada: E
   - Letra 4: Y (valor num√©rico: 25) + C (valor num√©rico: 2) = A (valor num√©rico cifrado: 27-26) -> Letra cifrada: A

5. **Obtener el mensaje cifrado:**
   - Concatenar las letras cifradas para formar el mensaje cifrado final.

   **Ejemplo 1:**
   - Mensaje cifrado: ZSNR

   **Ejemplo 2:**
   - Mensaje cifrado: TJEA

Este es el proceso b√°sico del algoritmo de cifrado de Vigen√®re. Para implementarlo en un programa, necesitar√≠as funciones para convertir letras en valores num√©ricos y viceversa, as√≠ como la tabla de Vigen√®re para encontrar las coincidencias. Puedes utilizar ciclos y operaciones matem√°ticas para realizar las sumas y c√°lculos necesarios.

Recuerda que el cifrado de Vigen√®re es un cifrado cl√°sico y no se considera seguro en la actualidad. Sin embargo, es un buen ejercicio

<img src="img/cuadro_vigenere.png"  height="600">

Tabla de Vigen√®re

# üö® Requerimientos no funcionales

- Calidad:
  - Aplicar el estilo de c√≥digo definido por la comunidad, utilizando RuboCop como herramienta de apoyo.
  - Incluir pruebas unitarias para garantizar la calidad del c√≥digo.

- Desempe√±o y escalabilidad:
  - Permitir la ejecuci√≥n desde la l√≠nea de comandos y mostrar la salida en la consola de manera eficiente y r√°pida.

- C√≥digo fuente:
  - Desarrollar una soluci√≥n orientada a objetos, siguiendo los principios de la programaci√≥n orientada a objetos (POO).
  - Escribir m√©todos peque√±os y con un solo prop√≥sito para mejorar la legibilidad y el mantenimiento del c√≥digo.
  - Aplicar los principios SOLID para lograr un dise√±o modular, flexible y de f√°cil extensibilidad.

# üìö Recursos

- [Desarrollo Basado en Pruebas](https://brightcoders-2.gitbook.io/brightcoders-handbook/recursos/ruby-on-rails/desarrollo-basado-en-pruebas)
- [RuboCop](https://brightcoders-2.gitbook.io/brightcoders-handbook/recursos/ruby-on-rails/rubocop)
- [Principios SOLID y Polimorfismo](https://brightcoders-2.gitbook.io/brightcoders-handbook/recursos/ruby-on-rails/solid-and-polimorfismo)
- [Git & Github](https://brightcoders-2.gitbook.io/brightcoders-handbook/recursos/git-and-github/git-and-github)
